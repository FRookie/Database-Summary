# Database-Summary

## 数据库引擎：
### MyISAM：
 
    1)基于ISAM存储引擎，并在其基础上进行扩展，不支持事务。
    2)不支持外键（<kbd>Foreign_Key</kbd>）。
    3)读写操作属于串行模式，如果对同一张表进行读写操作时，写操作的进程会优先获取锁，因此不适合执行有大量读取和更新操作的数据，适合读操作多的少量数据。
    4)采用表级锁（共享锁和排它锁），这类锁的特点是：资源开销少，加锁的速度快，不会出现死锁，并发的程度低，加锁的粒度大，冲突概率比较高。
    5)不保存表记录数，执行'select count(1) from xxx'时会进行全表扫描。
    6)创建数据库将会产生3个文件，.frm存储表结构，.MYD存储表数据，.MYI存储表索引，索引被压缩过。
### InnoDB:
  
    1)为Mysql在事务提交，回滚，灾难恢复等安全方面提供了支持。
    2)支持外键(<kbd>Foreign_Key</kbd>)。
    3)与Mysql完全整合，是为了处理巨大量数据而设计。
    4)支持表级锁与行级锁，默认为行级锁。行级锁开销大，加锁慢，锁粒度小，冲突概率低，并发度高，会出现死锁。表级锁一般由数据库内部进行，因此不需要特别的关注。
    5)保留表记录数，当执行'select count(1) from xxx'时不会进行全表扫描。
    6)索引与数据紧密捆绑，索引没有压缩。在索引方面的内存使用率，不如MyISAM。

### 比较：

  |          |     MyISAM     |     InnoDB     |
  | :---- | :----: | :----: |
  | 存储限制 | 无限制 | 64TB |
  | 锁机制 | 表锁 | 表锁·行锁 |
  | 死锁 | 不会 | 会 |
  | B树索引 | 是 | 是 |
  | 全文索引 | 支持 |  |
  | 集群索引 | 不支持 | 支持 |
  | 数据可压缩 | 支持 | 不支持 |
  | 空间使用率 | 低 | 高 |
  | 内存使用率 | 低 | 高 |
  | 批量插入速度 | 高 | 低 |
  | 外键 | 不支持 | 支持 |
  | 事务 | 不支持 | 支持 |

### 事务：
> 1、什么是事务
   >> 事务是一条或多条数据库操作语句的组合，具备ACID，4个特点。 
   
   >>> 原子性：要不全部成功，要不全部撤销
   
   >>> 隔离性：事务之间相互独立，互不干扰
   
   >>> 一致性：数据库正确地改变状态后，数据库的一致性约束没有被破坏
   
   >>> 持久性：事务的提交结果，将持久保存在数据库中

> 2、事务并发会产生什么问题
 >> 1. 第一类丢失更新：在没有事务隔离的情况下，两个事务都同时更新一行数据，但是第二个事务却中途失败退出， 导致对数据的两个修改都失效了。
 >> 2. 脏读：脏读就是指当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。
 >> 3. 不可重复读：是指在一个事务内，多次读同一数据。在这个事务还没有结束时，另外一个事务也访问该同一数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改，那么第一个事务两次读到的的数据可能是不一样的。这样就发生了在一个事务内两次读到的数据是不一样的，因此称为是不可重复读。
 >> 4. 第二类丢失更新：不可重复读的特例。有两个并发事务同时读取同一行数据，然后其中一个对它进行修改提交，而另一个也进行了修改提交。这就会造成第一次写操作失效。 
 >> 5. 幻读：是指当事务不是独立执行时发生的一种现象，例如第一个事务对一个表中的数据进行了修改，这种修改涉及到表中的全部数据行。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入一行新数据。那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好象发生了幻觉一样。

#### 提醒：
不可重复读的重点是修改，同样的条件，你读取过的数据，再次读取出来发现值不一样了。<br/>
幻读的重点在于新增或者删除，同样的条件，第 1 次和第 2 次读出来的记录数不一样。<br/>

> 3、事务隔离级别，解决什么并发问题，以及存在什么并发问题

>> 1. READ_UNCOMMITTED

   >>> 这是事务最低的隔离级别，它充许另外一个事务可以看到这个事务未提交的数据。

   >>> 解决第一类丢失更新的问题，但是会出现脏读、不可重复读、第二类丢失更新的问题，幻读 。
  
>> 2. READ_COMMITTED

   >>> 保证一个事务修改的数据提交后才能被另外一个事务读取，即另外一个事务不能读取该事务未提交的数据。

   >>> 解决第一类丢失更新和脏读的问题，但会出现不可重复读、第二类丢失更新的问题，幻读问题。
  
>> 3. REPEATABLE_READ

   >>> 保证一个事务相同条件下前后两次获取的数据是一致的。 
  
   >>> 解决第一类丢失更新，脏读、不可重复读、第二类丢失更新的问题，但会出幻读。
    
>> 4. SERIALIZABLE

　　>>> 事务被处理为顺序执行。
  
　　>>> 解决所有问题

#### 提醒：

Mysql默认的事务隔离级别为repeatable_read。

> 4、MyIsAm引擎的锁机制

>> 共享锁：可同时读、读的同时不能写

>> 独占锁：写的同时不能读和写


如何加锁：

select前，对所有涉及的表自动加共享锁

更新数据时，加独占写锁


MyIsAM支持并发插入：读的时候插入，但是插入的数据当前事务无法读取

设置参数concurrent_Insert

0:不允许并发插入，1：无空洞，允许并发插入，2：有无都允许并发插入

空洞：删除记录造成

> 5、InnoDB引擎的锁机制

（之所以以InnoDB为主介绍锁，是因为InnoDB支持事务，支持行锁和表锁用的比较多，Myisam不支持事务，只支持表锁）
共享锁（S）：允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁。
排他锁（X)：允许获得排他锁的事务更新数据，阻止其他事务取得相同数据集的共享读锁和排他写锁。
意向共享锁（IS）：事务打算给数据行加行共享锁，事务在给一个数据行加共享锁前必须先取得该表的IS锁。
意向排他锁（IX）：事务打算给数据行加行排他锁，事务在给一个数据行加排他锁前必须先取得该表的IX锁。

说明：

1）共享锁和排他锁都是行锁，意向锁都是表锁，应用中我们只会使用到共享锁和排他锁，意向锁是mysql内部使用的，不需要用户干预。

2）对于UPDATE、DELETE和INSERT语句，InnoDB会自动给涉及数据集加排他锁（X)；对于普通SELECT语句，InnoDB不会加任何锁，事务可以通过以下语句显示给记录集加共享锁或排他锁。
共享锁（S）：SELECT * FROM table_name WHERE ... LOCK IN SHARE MODE。
排他锁（X)：SELECT * FROM table_name WHERE ... FOR UPDATE。

3）InnoDB行锁是通过给索引上的索引项加锁来实现的，因此InnoDB这种行锁实现特点意味着：只有通过索引条件检索数据，InnoDB才使用行级锁，否则，InnoDB将使用表锁！。
